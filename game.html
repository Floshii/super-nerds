<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #0a0a20;
      color: #fff;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      margin: 10px auto;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      border: 2px solid #00ff00;
    }
    h1 {
      color: #0f0;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin: 10px 0;
      text-align: center;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
      font-size: 24px;
    }
    button {
      background-color: #222;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 8px 16px;
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
    }
    button:hover {
      background-color: #0f0;
      color: #000;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border: 2px solid #ff0000;
      z-index: 100;
    }
    #levelUp {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border: 2px solid #00ff00;
      z-index: 100;
    }
    #endScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border: 2px solid #00ffff;
      z-index: 100;
    }
    #endScreen h2 {
      color: #00ffff;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin: 10px 0;
      text-align: center;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }
    #endScreen button {
      background-color: #222;
      color: #00ffff;
      border: 2px solid #00ffff;
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 16px;
    }
    #endScreen button:hover {
      background-color: #00ffff;
      color: #000;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }
    .instructions {
      background-color: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #0f0;
      margin: 10px 0;
      font-size: 12px;
      max-width: 500px;
      text-align: center;
    }
    #levelInfo {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 5px 10px;
      border-radius: 5px;
      border: 1px solid #0f0;
      font-size: 12px;
      text-align: right;
    }
    .email-form {
      margin-top: 15px;
      width: 100%;
      max-width: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .email-form input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      background-color: #222;
      color: #0f0;
      border: 2px solid #0f0;
      font-family: 'Courier New', monospace;
      outline: none;
    }
    .email-form input:focus {
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
    }
    .email-form label {
      margin-bottom: 5px;
      color: #0f0;
      font-size: 14px;
      text-align: center;
    }
    .email-form button {
      margin-top: 5px;
    }
    .email-form .message {
      margin-top: 5px;
      font-size: 12px;
      color: #0f0;
      text-align: center;
    }
    #gameOverButtons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
      width: 100%;
      max-width: 300px;
    }
    .continue-hint {
      font-size: 12px;
      color: #ff9900;
      margin-top: 10px;
      text-align: center;
    }
    #continueFromLevelButton:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.38.4/dist/umd/supabase.min.js"></script>
  <script>
    // Supabase configuration
    const SUPABASE_URL = 'https://fqdfoalxokjfsknqqcwz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZxZGZvYWx4b2tqZnNrbnFxY3d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDIxMjIsImV4cCI6MjA1NjU3ODEyMn0.mm8NQGRQ8fxkKL_8jV5R5LdGy9A73jwjXH9ug7OEgTk';
    
    // Initialize Supabase client
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    // File d'attente pour les op√©rations Supabase
    const supabaseQueue = [];
    let isProcessingQueue = false;
    
    // Fonction pour traiter la file d'attente en arri√®re-plan
    async function processSupabaseQueue() {
      if (isProcessingQueue || supabaseQueue.length === 0) return;
      
      isProcessingQueue = true;
      
      try {
        const item = supabaseQueue.shift();
        
        if (item && item.type === 'saveScore') {
          try {
            const { data, error } = await supabaseClient
              .from('leaderboard')
              .insert([{ 
                email: item.email, 
                score: item.score, 
                level: item.level
              }]);
              
            if (error && DEBUG) {
              console.error('Erreur Supabase lors du traitement de la file:', error);
            }
          } catch (err) {
            if (DEBUG) console.error('Erreur lors du traitement de la file:', err);
          }
        }
      } finally {
        isProcessingQueue = false;
        
        // Continuer √† traiter la file si d'autres √©l√©ments sont pr√©sents
        if (supabaseQueue.length > 0) {
          setTimeout(processSupabaseQueue, 1000); // Attendre 1 seconde avant de traiter le prochain √©l√©ment
        }
      }
    }
    
    // Fonction pour enregistrer le score - version optimis√©e
    async function saveScore(email, score, level) {
      if (DEBUG) console.log(`Enregistrement du score: ${score} points pour ${email} au niveau ${level}`);
      
      // Toujours sauvegarder localement d'abord (rapide)
      saveScoreLocally(email, score, level);
      
      // Ajouter √† la file d'attente pour Supabase (traitement en arri√®re-plan)
      supabaseQueue.push({
        type: 'saveScore',
        email: email,
        score: score,
        level: level
      });
      
      // D√©marrer le traitement de la file si ce n'est pas d√©j√† fait
      setTimeout(processSupabaseQueue, 100);
      
      // Retourner imm√©diatement un succ√®s (puisque sauvegard√© localement)
      return { success: true };
    }
    
    // Fonction de sauvegarde locale (fallback)
    function saveScoreLocally(email, score, level) {
      if (DEBUG) console.log(`Sauvegarde locale du score: ${score} points pour ${email} au niveau ${level}`);
      
      const scoreData = {
        email: email,
        score: score,
        level: level,
        date: new Date().toISOString()
      };
      
      let savedScores = JSON.parse(localStorage.getItem('superNerdsScores') || '[]');
      savedScores.push(scoreData);
      localStorage.setItem('superNerdsScores', JSON.stringify(savedScores));
    }
    
    // Rendre la fonction disponible globalement
    window.saveScore = saveScore;
  </script>
</head>
<body>
  <h1>The Super Nerds Adventure</h1>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="levelInfo">
      <p>Level: <span id="currentLevel">1</span> - <span id="levelName">The Nerd Awakens</span></p>
    </div>
    <div id="gameOver">
      <h2>GAME OVER</h2>
      <p>Your Score: <span id="finalScore">0</span></p>
      <div class="email-form">
        <label for="leaderboardEmail">Enter your email to save your score:</label>
        <input type="email" id="leaderboardEmail" placeholder="your@email.com">
        <button id="submitEmail">Save Score</button>
        <div id="emailMessage" class="message"></div>
      </div>
      <div id="gameOverButtons">
        <button id="restartButton">Start Over</button>
        <button id="continueFromLevelButton" disabled>Continue from Level <span id="currentLevelGameOver">1</span></button>
      </div>
      <p class="continue-hint">Submit your email to unlock the continue option!</p>
    </div>
    <div id="levelUp">
      <h2>LEVEL UP!</h2>
      <p>Welcome to Level <span id="newLevel">2</span>:</p>
      <h3><span id="newLevelName">The First Code</span></h3>
      <p id="levelDescription">Your journey continues as you face new challenges...</p>
      <button id="continueButton">Continue</button>
    </div>
    <div id="endScreen">
      <h2>CONGRATULATIONS!</h2>
      <p>"Business is just another game"</p>
      <button id="unlockSuperPowersButton">D√©bloque de vrais super-pouvoirs</button>
      <button id="continuePlayingButton" style="margin-top: 15px;">Continue Playing</button>
    </div>
    </div>
  </div>
  <button id="startButton">Start Game</button>
  <div class="instructions">
    <p>ARROW KEYS to move | SPACE to shoot | Collect power-ups!</p>
    <p>Progress through life stages from teenage nerd to adult super nerds!</p>
    <p>Made with love by <a href="https://www.youtube.com/@FlorentThurin" target="_blank" style="color: #0f0; text-decoration: underline;">Florent Thurin</a></p>
  </div>

  <script>
    // DOM elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const continueButton = document.getElementById('continueButton');
    const continueFromLevelButton = document.getElementById('continueFromLevelButton');
    const submitEmailButton = document.getElementById('submitEmail');
    const leaderboardEmail = document.getElementById('leaderboardEmail');
    const emailMessage = document.getElementById('emailMessage');
    const unlockSuperPowersButton = document.getElementById('unlockSuperPowersButton');
    const continuePlayingButton = document.getElementById('continuePlayingButton');
    
    // Debug mode - set to false to disable console logs
    const DEBUG = false;
    
    // Ajouter apr√®s les constantes DOM et avant les variables de jeu
    
    // Game variables
    let ship;
    let bullets = [];
    let obstacles = [];
    let stars = [];
    let particles = [];
    let textParticles = [];
    let powerUps = [];
    let activePowerUps = {};
    let miniBoss = null;
    let bossDefeated = false;
    let score = 0;
    let gameRunning = false;
    let keys = {};
    let frameCount = 0;
    
    // Level system
    let currentLevel = 1;
    let scoreForNextLevel = 1000;
    let levelMultiplier = 1.5;
    
// Level definitions
const LEVELS = [
  {
    id: 1,
    name: "The Nerd Awakens",
    description: "Teenage troubles: school, gaming, coding for fun, internet lag.",
    obstacles: ["Math homework", "Mom cutting the WiFi", "Lag spike", "No save point"],
    powerUps: ["Mode Tryhard Activ√©", "CheatCode D√©bloqu√©", "Copier-coller Stack Overflow", "Assistant IA"],
    explosionMessages: [
      "Maman, encore 5 minutes !",
      "Bug dans ton jeu",
      "Patch sur la prochaine mise √† jour.",
      "GG, go next.",
    ]
  },
  {
    id: 2,
    name: "The First Code",
    description: "First internships, first failures, first contact with legacy code.",
    obstacles: ["Unpaid internship", "Approaching deadline", "Spaghetti code", "Merge conflict", "Legacy code"],
    powerUps: ["Mode Debug", "Nouveau Framework Hype", "Canard en Plastique", "Assistant IA"],
    explosionMessages: [
      "Corrig√© en prod... enfin je crois.",
      "Oublie pas le point-virgule.",
      "Bienvenue dans Jira hell.",
      "Ton pull request a √©t√© refus√©.",
      "Chez moi, √ßa marche."

    ]
  },
  {
    id: 3,
    name: "Welcome to Adulthood",
    description: "Working for real now, but it's not fun anymore.",
    obstacles: ["Commute, work, sleep", "Annoying boss", "Useless meeting", "Technical debt"],
    powerUps: ["T√©l√©travail", "Caf√© de l'Open-space", "D√©veloppeur Junior Motiv√©", "Assistant IA"],
    explosionMessages: [
      "Bienvenue dans le burn-out !",
      "D√©ploiement rat√©, rollback en cours.",
      "Ton manager te regarde d'un mauvais ≈ìil.",
      "Ping-moi si urgent. (Tout est urgent.)",
      "Prod en PLS",
      "Dette technique",
      "R√©union inutile √©vit√©e"
    ]
  },
  {
    id: 4,
    name: "Life Strikes Back",
    description: "No more fooling around, time to pay the bills.",
    obstacles: ["Buying a house", "Planning a wedding", "Having kids", "Taxes"],
    powerUps: ["Compte joint", "Les enfants chez Mamie", "Week-end en solo", "Assistant IA"],
    explosionMessages: [
      "Ton √©pargne vient de dispara√Ætre.",
      "Tu dors plus, d√©sol√©.",
      "Tes imp√¥ts pour payer leur resto",
      "T'es responsable d'un mini-toi maintenant.",
      "F√©licitations, tu es devenu tes parents."
    ]
  },
  {
    id: 5,
    name: "The Final Boss: Time",
    description: "Too late to turn back, regrets are starting to pile up...",
    obstacles: ["Midlife Crisis", "Not a minute to waste", "Failed retirement plan"],
    powerUps: ["Retraite anticip√©e", "Vacances √† la mer", "Assistant IA"],
    explosionMessages: [
      "Encore un jour de plus vers la retraite.",
      "childhood.exe a cess√© de fonctionner.",
      "Crise existentielle en cours...",
      "Pourquoi j'ai pas achet√© du Bitcoin en 2010 ?",
      "Crise de la quarantaine",
      "Plus une minute √† perdre",
      "Plan retraite foireux"
    ]
  }
];

    // Power-up types
    const POWER_UP_TYPES = [
      // Level 1 power-ups
      {
        name: "Mode Gaming: ON",
        color: [255, 0, 255],
        size: 25,
        duration: 8 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "MODE GAMING: ON!");
              ship.speedBoost = 2;
            },
            onUpdate: function() {
              if (frameCount % 10 === 0) {
                bullets.push({
                  x: ship.x,
                  y: ship.y - 10,
                  vx: 0,
                  vy: -10,
                  special: true
                });
              }
            },
            onDeactivate: function() {
              ship.speedBoost = 1;
              createTextParticle(ship.x, ship.y - 30, "Game Over!");
            }
          };
        }
      },
      {
        name: "Code de Triche D√©bloqu√©",
        color: [255, 255, 0],
        size: 25,
        duration: 8 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "CODE DE TRICHE D√âBLOQU√â!");
            },
            onUpdate: function() {
              if (frameCount % 10 === 0) {
                for (let angle = 0; angle < 360; angle += 45) {
                  let rad = angle * Math.PI / 180;
                  bullets.push({
                    x: ship.x,
                    y: ship.y,
                    vx: Math.cos(rad) * 5,
                    vy: Math.sin(rad) * 5,
                    special: true
                  });
                }
              }
            }
          };
        }
      },
      {
        name: "Copier-coller Stack Overflow",
        color: [255, 165, 0],
        size: 25,
        duration: 1,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "COPIER-COLLER DE STACK OVERFLOW!");
              for (let obstacle of obstacles) {
                if (obstacle.y < canvas.height / 2) {
                  createExplosion(obstacle.x, obstacle.y, obstacle.size, obstacle.color);
                  score += Math.floor(obstacle.size);
                }
              }
              obstacles = obstacles.filter(o => o.y >= canvas.height / 2);
            }
          };
        }
      },
      
      // New AI Assistant power-up
      {
        name: "Assistant IA",
        color: [0, 200, 255],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "ASSISTANT IA ACTIV√â!");
            },
            onUpdate: function() {
              // Find the closest obstacle
              if (obstacles.length > 0 && frameCount % 15 === 0) {
                let closestObstacle = null;
                let minDistance = Infinity;
                
                for (let obstacle of obstacles) {
                  const dx = obstacle.x - ship.x;
                  const dy = obstacle.y - ship.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance < minDistance) {
                    minDistance = distance;
                    closestObstacle = obstacle;
                  }
                }
                
                if (closestObstacle) {
                  // Calculate direction to the obstacle
                  const dx = closestObstacle.x - ship.x;
                  const dy = closestObstacle.y - ship.y;
                  const angle = Math.atan2(dy, dx);
                  
                  // Create a special AI bullet
                  bullets.push({
                    x: ship.x,
                    y: ship.y - 10,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    special: true,
                    ai: true
                  });
                  
                  // Visual effect
                  createTextParticle(ship.x + 20, ship.y, "ü§ñ", 20);
                }
              }
            },
            onDeactivate: function() {
              createTextParticle(ship.x, ship.y - 30, "ASSISTANT IA HORS LIGNE");
            }
          };
        }
      },
      
      // Level 2 power-ups
      {
        name: "Mode Debug",
        color: [255, 255, 0],
        size: 25,
        duration: 8 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "MODE DEBUG ACTIV√â!");
            },
            onUpdate: function() {
              if (frameCount % 10 === 0) {
                for (let angle = 0; angle < 360; angle += 45) {
                  let rad = angle * Math.PI / 180;
                  bullets.push({
                    x: ship.x,
                    y: ship.y,
                    vx: Math.cos(rad) * 5,
                    vy: Math.sin(rad) * 5,
                    special: true
                  });
                }
              }
            }
          };
        }
      },
      {
        name: "Nouveau Framework Hype",
        color: [0, 200, 255],
        size: 25,
        duration: 15 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "NOUVEAU FRAMEWORK HYPE!");
              ship.speedBoost = 3;
              ship.doubleDamage = true;
            },
            onUpdate: function() {
              if (frameCount % 30 === 0) {
                createTextParticle(ship.x, ship.y - 30, "Tellement productif!");
              }
            },
            onDeactivate: function() {
              ship.speedBoost = 1;
              ship.doubleDamage = false;
              createTextParticle(ship.x, ship.y - 30, "Framework abandonn√©!");
            }
          };
        }
      },
      {
        name: "Canard en Plastique",
        color: [255, 255, 0],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          let duckX = ship.x + 30;
          let duckY = ship.y;
          
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "CANARD EN PLASTIQUE ACTIV√â!");
            },
            onUpdate: function() {
              // Update duck position to follow player with slight delay
              duckX += (ship.x + 30 - duckX) * 0.1;
              duckY += (ship.y - duckY) * 0.1;
              
              // Duck shoots occasionally
              if (frameCount % 15 === 0) {
                bullets.push({
                  x: duckX,
                  y: duckY,
                  vx: 0,
                  vy: -8,
                  special: true
                });
              }
              
              // Draw the duck
              ctx.fillStyle = 'rgb(255, 255, 0)';
              ctx.beginPath();
              ctx.arc(duckX, duckY, 10, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              // Duck's bill
              ctx.fillStyle = 'rgb(255, 165, 0)';
              ctx.beginPath();
              ctx.ellipse(duckX + 10, duckY, 5, 3, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            }
          };
        }
      },
      
      // Level 3 power-ups
      {
        name: "T√©l√©travail",
        color: [100, 200, 255],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "T√âL√âTRAVAIL ACTIV√â!");
              for (let obstacle of obstacles) {
                obstacle.originalVx = obstacle.vx;
                obstacle.originalVy = obstacle.vy;
                obstacle.vx *= 0.3;
                obstacle.vy *= 0.3;
              }
            },
            onDeactivate: function() {
              for (let obstacle of obstacles) {
                if (obstacle.originalVx !== undefined) {
                  obstacle.vx = obstacle.originalVx;
                  obstacle.vy = obstacle.originalVy;
                }
              }
              createTextParticle(ship.x, ship.y - 30, "Retour au bureau!");
            }
          };
        }
      },
      {
        name: "Caf√© de l'Open-space",
        color: [139, 69, 19],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "BOOST DE CAF√â!");
              ship.speedBoost = 2;
            },
            onUpdate: function() {
              if (keys[32] && frameCount % 5 === 0) {
                bullets.push({
                  x: ship.x,
                  y: ship.y - 10,
                  vx: 0,
                  vy: -12,
                  special: true
                });
              }
            },
            onDeactivate: function() {
              ship.speedBoost = 1;
              createTextParticle(ship.x, ship.y - 30, "Coffee crash!");
            }
          };
        }
      },
      {
        name: "AI Pair Programming",
        color: [150, 0, 255],
        size: 25,
        duration: 15 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "AI PAIR PROGRAMMING!");
              ship.doubleDamage = true;
            },
            onUpdate: function() {
              // AI shoots automatically at nearest obstacle
              if (frameCount % 20 === 0 && obstacles.length > 0) {
                // Find closest obstacle
                let closestDist = Infinity;
                let closestObstacle = null;
                
                for (let obstacle of obstacles) {
                  let dist = Math.sqrt(Math.pow(ship.x - obstacle.x, 2) + Math.pow(ship.y - obstacle.y, 2));
                  if (dist < closestDist) {
                    closestDist = dist;
                    closestObstacle = obstacle;
                  }
                }
                
                if (closestObstacle) {
                  // Calculate direction to obstacle
                  let dx = closestObstacle.x - ship.x;
                  let dy = closestObstacle.y - ship.y;
                  let dist = Math.sqrt(dx * dx + dy * dy);
                  
                  // Normalize and set velocity
                  let vx = dx / dist * 10;
                  let vy = dy / dist * 10;
                  
                  bullets.push({
                    x: ship.x,
                    y: ship.y,
                    vx: vx,
                    vy: vy,
                    special: true
                  });
                }
              }
            },
            onDeactivate: function() {
              ship.doubleDamage = false;
              createTextParticle(ship.x, ship.y - 30, "AI subscription ended!");
            }
          };
        }
      },
      
      // Level 4 power-ups
      {
        name: "Joint Bank Account Shield",
        color: [0, 200, 100],
        size: 25,
        duration: 8 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "FINANCIAL SHIELD ACTIVATED!");
              ship.shield = true;
            },
            onUpdate: function() {
              // Draw shield
              ctx.strokeStyle = 'rgba(0, 200, 100, 0.7)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(ship.x, ship.y, 25, 0, Math.PI * 2);
              ctx.stroke();
            },
            onDeactivate: function() {
              ship.shield = false;
              createTextParticle(ship.x, ship.y - 30, "Account overdrawn!");
            }
          };
        }
      },
      {
        name: "Daycare Time",
        color: [255, 100, 255],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "KIDS AT DAYCARE!");
              for (let obstacle of obstacles) {
                obstacle.originalVx = obstacle.vx;
                obstacle.originalVy = obstacle.vy;
                obstacle.vx *= 0.2;
                obstacle.vy *= 0.2;
              }
            },
            onDeactivate: function() {
              for (let obstacle of obstacles) {
                if (obstacle.originalVx !== undefined) {
                  obstacle.vx = obstacle.originalVx;
                  obstacle.vy = obstacle.originalVy;
                }
              }
              createTextParticle(ship.x, ship.y - 30, "Daycare closed!");
            }
          };
        }
      },
      {
        name: "One Free Weekend",
        color: [0, 255, 255],
        size: 25,
        duration: 1,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "FREE WEEKEND!");
              for (let obstacle of obstacles) {
                createExplosion(obstacle.x, obstacle.y, obstacle.size, obstacle.color);
                score += Math.floor(obstacle.size);
              }
              obstacles = [];
            }
          };
        }
      },
      
      // Level 5 power-ups
      {
        name: "Retraite anticip√©e",
        color: [255, 215, 0],
        size: 25,
        duration: 1,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "RETRAITE ANTICIP√âE!");
              for (let obstacle of obstacles) {
                createExplosion(obstacle.x, obstacle.y, obstacle.size, obstacle.color);
                score += Math.floor(obstacle.size * 2);
              }
              obstacles = [];
              
              // Bonus score
              score += 500;
            }
          };
        }
      },
      {
        name: "Vacances √† la mer",
        color: [200, 200, 255],
        size: 25,
        duration: 15 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "VACANCES √Ä LA MER!");
              ship.doubleDamage = true;
              
              // Slow down all obstacles
              for (let obstacle of obstacles) {
                obstacle.originalVx = obstacle.vx;
                obstacle.originalVy = obstacle.vy;
                obstacle.vx *= 0.1;
                obstacle.vy *= 0.1;
              }
            },
            onUpdate: function() {
              // Slow down any new obstacles
              for (let obstacle of obstacles) {
                if (obstacle.originalVx === undefined) {
                  obstacle.originalVx = obstacle.vx;
                  obstacle.originalVy = obstacle.vy;
                  obstacle.vx *= 0.1;
                  obstacle.vy *= 0.1;
                }
              }
            },
            onDeactivate: function() {
              ship.doubleDamage = false;
              
              // Return obstacles to normal speed
              for (let obstacle of obstacles) {
                if (obstacle.originalVx !== undefined) {
                  obstacle.vx = obstacle.originalVx;
                  obstacle.vy = obstacle.originalVy;
                }
              }
              createTextParticle(ship.x, ship.y - 30, "Retour au travail!");
            }
          };
        }
      },
      {
        name: "Weekend Mode",
        color: [0, 191, 255],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "WEEKEND MODE!");
              for (let obstacle of obstacles) {
                obstacle.originalVx = obstacle.vx;
                obstacle.originalVy = obstacle.vy;
                obstacle.vx *= 0.3;
                obstacle.vy *= 0.3;
              }
            },
            onDeactivate: function() {
              for (let obstacle of obstacles) {
                if (obstacle.originalVx !== undefined) {
                  obstacle.vx = obstacle.originalVx;
                  obstacle.vy = obstacle.originalVy;
                }
              }
            }
          };
        }
      },
      {
        name: "Compte joint",
        color: [0, 200, 100],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "BOUCLIER FINANCIER ACTIV√â!");
              ship.shield = true;
            },
            onUpdate: function() {
              // Draw shield
              ctx.strokeStyle = 'rgba(0, 200, 100, 0.7)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(ship.x, ship.y, 25, 0, Math.PI * 2);
              ctx.stroke();
            },
            onDeactivate: function() {
              ship.shield = false;
              createTextParticle(ship.x, ship.y - 30, "Compte √† d√©couvert!");
            }
          };
        }
      },
      {
        name: "Les enfants chez Mamie",
        color: [255, 100, 255],
        size: 25,
        duration: 10 * 60,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "ENFANTS CHEZ MAMIE!");
              for (let obstacle of obstacles) {
                obstacle.originalVx = obstacle.vx;
                obstacle.originalVy = obstacle.vy;
                obstacle.vx *= 0.2;
                obstacle.vy *= 0.2;
              }
            },
            onDeactivate: function() {
              for (let obstacle of obstacles) {
                if (obstacle.originalVx !== undefined) {
                  obstacle.vx = obstacle.originalVx;
                  obstacle.vy = obstacle.originalVy;
                }
              }
              createTextParticle(ship.x, ship.y - 30, "Mamie a ramen√© les enfants!");
            }
          };
        }
      },
      {
        name: "Week-end en solo",
        color: [0, 255, 255],
        size: 25,
        duration: 1,
        effect: function(ship) {
          return {
            onActivate: function() {
              createTextParticle(ship.x, ship.y - 30, "WEEK-END EN SOLO!");
              for (let obstacle of obstacles) {
                createExplosion(obstacle.x, obstacle.y, obstacle.size, obstacle.color);
                score += Math.floor(obstacle.size);
              }
              obstacles = [];
            }
          };
        }
      }
    ];
    
    // Obstacle types with funny texts
    const OBSTACLE_TYPES = [
      // Level 1: The Nerd Awakens
      { 
        name: "Homework Comet", 
        size: 40, 
        color: [200, 200, 100], 
        health: 2,
        texts: []
      },
      { 
        name: "Mom Unplugging WiFi", 
        size: 35, 
        color: [255, 100, 100], 
        health: 1,
        texts: []
      },
      { 
        name: "Lag Spike", 
        size: 25, 
        color: [255, 0, 0], 
        health: 1,
        texts: []
      },
      { 
        name: "Git Push -f Accident", 
        size: 45, 
        color: [150, 75, 0], 
        health: 2,
        texts: []
      },
      { 
        name: "Spaghetti Code Monster", 
        size: 50, 
        color: [255, 165, 0], 
        health: 3,
        texts: []
      },
      
      // Level 2: The First Code
      { 
        name: "Unpaid Internship", 
        size: 40, 
        color: [100, 100, 100], 
        health: 2,
        texts: []
      },
      { 
        name: "Deadline Meteor", 
        size: 45, 
        color: [255, 0, 0], 
        health: 2,
        texts: []
      },
      { 
        name: "Technical Debt Satellite", 
        size: 50, 
        color: [150, 75, 75], 
        health: 3,
        texts: []
      },
      { 
        name: "Merge Conflict Drone", 
        size: 30, 
        color: [150, 0, 255], 
        health: 1,
        texts: []
      },
      { 
        name: "Legacy Code Wormhole", 
        size: 50, 
        color: [100, 100, 100], 
        health: 3,
        texts: []
      },
      
      // Level 3: Welcome to Adulthood
      { 
        name: "9 to 5 Comet", 
        size: 40, 
        color: [100, 100, 150], 
        health: 2,
        texts: []
      },
      { 
        name: "Micromanaging Boss Ship", 
        size: 45, 
        color: [200, 0, 0], 
        health: 2,
        texts: []
      },
      { 
        name: "Infinite Meetings", 
        size: 35, 
        color: [150, 150, 150], 
        health: 2,
        texts: []
      },
      { 
        name: "Prod Outage Satellite", 
        size: 50, 
        color: [255, 100, 0], 
        health: 3,
        texts: []
      },
      
      // Level 4: The Boss Fight: Life Itself
      { 
        name: "Getting a Mortgage", 
        size: 55, 
        color: [100, 100, 100], 
        health: 3,
        texts: []
      },
      { 
        name: "Wedding Planner UFO", 
        size: 40, 
        color: [255, 192, 203], 
        health: 2,
        texts: []
      },
      { 
        name: "Parenthood Debris", 
        size: 45, 
        color: [0, 100, 255], 
        health: 2,
        texts: []
      },
      { 
        name: "Taxes Black Hole", 
        size: 50, 
        color: [50, 50, 50], 
        health: 3,
        texts: []
      },
      
      // Level 5: The Final Boss: Time
      { 
        name: "Midlife Crisis Meteor", 
        size: 50, 
        color: [255, 0, 100], 
        health: 2,
        texts: []
      },
      { 
        name: "No Time Left", 
        size: 45, 
        color: [200, 200, 200], 
        health: 1,
        texts: []
      },
      { 
        name: "Retirement Fund Gone", 
        size: 55, 
        color: [100, 0, 0], 
        health: 2,
        texts: []
      }
    ];
    
    // Mini-Boss definitions for each level
    const MINI_BOSSES = [
      // Level 1: L'√âveil du Nerd
      {
        name: "Addiction aux Jeux Vid√©o",
        description: "Ton premier vrai d√©fi : √©quilibrer le gaming avec la vraie vie !",
        health: 20,
        size: 70,
        color: [255, 50, 50],
        speed: 2,
        shootInterval: 90,
        attackMessages: [
          "Encore une partie !",
          "Dormir c'est pour les faibles !",
          "Je ferai mes devoirs plus tard !",
          "5 minutes de plus, Maman !"
        ]
      },
      // Level 2: Le Premier Code
      {
        name: "Syndrome de l'Imposteur",
        description: "Tout le monde semble en savoir plus que toi. Es-tu vraiment d√©veloppeur ?",
        health: 30,
        size: 75,
        color: [100, 100, 255],
        speed: 2.5,
        shootInterval: 80,
        attackMessages: [
          "Ils vont d√©couvrir que je suis un imposteur !",
          "Stack Overflow est mon vrai CV !",
          "Je n'ai pas ma place ici !",
          "Tout le monde en sait plus que moi !"
        ]
      },
      // Level 3: Bienvenue dans l'√Çge Adulte
      {
        name: "Burn-out",
        description: "Le rythme implacable de la vie adulte te rattrape.",
        health: 40,
        size: 80,
        color: [255, 100, 0],
        speed: 3,
        shootInterval: 70,
        attackMessages: [
          "Pas d'√©quilibre vie pro/perso !",
          "Besoin de plus de caf√© !",
          "Les emails n'arr√™tent jamais !",
          "Week-end ? C'est quoi √ßa ?"
        ]
      },
      // Level 4: La Vie Contre-Attaque
      {
        name: "Cr√©dit & Factures",
        description: "Le monstre ultime des responsabilit√©s adultes.",
        health: 50,
        size: 85,
        color: [50, 200, 50],
        speed: 3.5,
        shootInterval: 60,
        attackMessages: [
          "Ton score de cr√©dit chute !",
          "Attaque de factures !",
          "Augmentation des imp√¥ts fonciers !",
          "R√©parations impr√©vues !"
        ]
      },
      // Level 5: Le Boss Final : Le Temps
      {
        name: "Crise de la Quarantaine",
        description: "O√π est pass√© tout ce temps ? Qu'as-tu accompli ?",
        health: 60,
        size: 90,
        color: [200, 0, 200],
        speed: 4,
        shootInterval: 50,
        attackMessages: [
          "La jeunesse est partie pour toujours !",
          "Qu'ai-je fait de ma vie ?",
          "Le temps n'attend personne !",
          "C'est tout ce qu'il y a ?"
        ]
      }
    ];
    
    // Pop culture reference texts
    const POP_CULTURE_TEXTS = [
      "Ce n'est pas une lune...",
      "C'est fini Anakin, j'ai le terrain sur√©lev√© !",
      "Force Quitter activ√©.",
      "Fais un tonneau !",
      "Appuie sur F pour rendre hommage.",
      "Succ√®s d√©bloqu√© !",
      "GG, pas de revanche.",
      "Nerf √ßa !"
    ];
    
    // Initialize game
    function init() {
      // Set up event listeners
      startButton.addEventListener('click', startGame);
      restartButton.addEventListener('click', restartGame);
      continueButton.addEventListener('click', continueGame);
      continueFromLevelButton.addEventListener('click', function() {
        // Double v√©rification que l'email a √©t√© soumis
        if (localStorage.getItem('emailSubmitted') === 'true') {
          continueFromCurrentLevel();
        } else {
          emailMessage.textContent = "Please submit your email first!";
          emailMessage.style.color = "#ff0000";
          // S'assurer que le bouton est d√©sactiv√©
          continueFromLevelButton.disabled = true;
        }
      });
      submitEmailButton.addEventListener('click', submitEmail);
      unlockSuperPowersButton.addEventListener('click', function() {
        window.open('https://florentthurin.com/', '_blank');
      });
      continuePlayingButton.addEventListener('click', continuePlaying);
      
      // Prevent default form submission
      document.addEventListener('submit', function(e) {
        e.preventDefault();
      });
      
      // Prevent space from triggering buttons when game is running
      document.addEventListener('click', function(e) {
        if (gameRunning && e.target.tagName === 'BUTTON' && e.detail === 0) {
          // This is likely a space-triggered click
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }, true);
      
      // Keyboard event listeners
      window.addEventListener('keydown', function(e) {
        keys[e.keyCode] = true;
        
        // Prevent space from scrolling or submitting forms
        if (e.keyCode === 32) {
          e.preventDefault();
        }
      });
      
      window.addEventListener('keyup', function(e) {
        keys[e.keyCode] = false;
        
        // Prevent space from triggering button clicks or form submissions
        if (e.keyCode === 32) {
          e.preventDefault();
        }
      });
      
      // Generate stars for background - more stars for larger canvas
      for (let i = 0; i < 200; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1
        });
      }
      
      resetGame();
    }
    
    function resetGame() {
      ship = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        speedBoost: 1,
        doubleDamage: false
      };
      bullets = [];
      obstacles = [];
      particles = [];
      textParticles = [];
      powerUps = [];
      activePowerUps = {};
      miniBoss = null;
      bossDefeated = false;
      
      // Only reset score when starting a new game, not when leveling up
      if (currentLevel === 1) {
        score = 0;
      }
      
      frameCount = 0;
      
      // Update level display
      document.getElementById('currentLevel').textContent = currentLevel;
      document.getElementById('levelName').textContent = LEVELS[currentLevel - 1].name;
      
      // Hide game over screen
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('levelUp').style.display = 'none';
      document.getElementById('endScreen').style.display = 'none';
      
      // Reset email form
      emailMessage.textContent = "";
      submitEmailButton.disabled = false;
    }
    
    function startGame() {
      resetGame();
      gameRunning = true;
      requestAnimationFrame(gameLoop);
    }
    
    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'flex';
      
      // Update current level display in game over screen
      document.getElementById('currentLevelGameOver').textContent = currentLevel;
      
      // Toujours d√©sactiver le bouton continue au d√©but
      continueFromLevelButton.disabled = true;
      
      // Load saved email if available
      const savedEmail = localStorage.getItem('playerEmail');
      if (savedEmail) {
        leaderboardEmail.value = savedEmail;
        
        // V√©rifier si l'email a √©t√© soumis pour cette session de jeu
        if (localStorage.getItem('emailSubmitted') === 'true') {
          // Activer le bouton uniquement si l'email a √©t√© soumis
          continueFromLevelButton.disabled = false;
        }
      }
    }
    
    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      currentLevel = 1;
      scoreForNextLevel = 1000;
      startGame();
    }
    
    function continueFromCurrentLevel() {
      // V√©rifier si l'email a √©t√© soumis
      if (localStorage.getItem('emailSubmitted') !== 'true') {
        // Si pas d'email soumis, afficher un message et ne pas continuer
        emailMessage.textContent = "Please submit your email first!";
        emailMessage.style.color = "#ff0000";
        return;
      }
      
      document.getElementById('gameOver').style.display = 'none';
      // Keep the current level, just reset the game state
      startGame();
    }
    
    function continueGame() {
      document.getElementById('levelUp').style.display = 'none';
      startGame();
    }
    
    function submitEmail() {
      const email = leaderboardEmail.value.trim();
      
      // Simple email validation
      if (!email || !email.includes('@') || !email.includes('.')) {
        emailMessage.textContent = "Please enter a valid email address.";
        emailMessage.style.color = "#ff0000";
        return;
      }
      
      // Show loading state
      emailMessage.textContent = "Saving score...";
      emailMessage.style.color = "#ffff00";
      submitEmailButton.disabled = true;
      
      // Sauvegarder le score (maintenant toujours synchrone gr√¢ce √† notre file d'attente)
      window.saveScore(email, score, currentLevel);
      
      // Afficher imm√©diatement un message de succ√®s
      emailMessage.textContent = "Score saved successfully! Thanks for playing!";
      emailMessage.style.color = "#0f0";
      
      // Enable the continue from level button
      continueFromLevelButton.disabled = false;
      
      // Save email in localStorage for convenience
      localStorage.setItem('playerEmail', email);
      localStorage.setItem('emailSubmitted', 'true');
      
      if (DEBUG) console.log(`Score saved for ${email} at level ${currentLevel}`);
    }
    
    function levelUp() {
      gameRunning = false;
      
      // Check if we're at the last level
      if (currentLevel >= LEVELS.length) {
        // Show end screen instead of level up
        showEndScreen();
        return;
      }
      
      // Update level up screen
      document.getElementById('newLevel').textContent = currentLevel + 1;
      document.getElementById('newLevelName').textContent = LEVELS[currentLevel].name;
      document.getElementById('levelDescription').textContent = LEVELS[currentLevel].description;
      
      // Show level up screen
      document.getElementById('levelUp').style.display = 'flex';
      
      // Prepare for next level
      currentLevel++;
      scoreForNextLevel = Math.floor(scoreForNextLevel * levelMultiplier);
      
      // Reset boss state for the new level
      bossDefeated = false;
    }
    
    // Game loop
    function gameLoop() {
      frameCount++;
      update();
      draw();
      
      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }
    
    // Update game state
    function update() {
      if (!gameRunning) return;
      
      // Move ship based on key presses
      if (keys.ArrowLeft && ship.x > ship.size / 2) ship.x -= ship.speed;
      if (keys.ArrowRight && ship.x < canvas.width - ship.size / 2) ship.x += ship.speed;
      if (keys.ArrowUp && ship.y > ship.size / 2) ship.y -= ship.speed;
      if (keys.ArrowDown && ship.y < canvas.height - ship.size / 2) ship.y += ship.speed;
      
      // Check for level up (only if not at max level and boss is defeated)
      if (score >= scoreForNextLevel && currentLevel < LEVELS.length && bossDefeated) {
        levelUp();
        return; // Skip the rest of the update after level up
      } else if (score >= scoreForNextLevel && currentLevel < LEVELS.length && !bossDefeated && !miniBoss) {
        // If player has enough score but hasn't defeated the boss yet, and the boss isn't spawned
        // Force spawn the boss if it's not already present
        if (frameCount % 60 === 0) { // Show reminder message once per second
          createTextParticle(canvas.width / 2, canvas.height / 2, "Defeat the boss to advance!");
        }
        
        // Make sure the boss is spawned
        if (!miniBoss) {
          if (DEBUG) console.log("Forcing boss spawn to complete level");
          spawnMiniBoss(true); // Force spawn the boss
        }
      }
      
      // Check for game completion
      checkGameCompletion();
      
      // Spawn mini-boss when reaching a percentage of the score needed for next level
      // Use a higher threshold for higher levels to give players more time
      let bossSpawnThreshold;
      if (currentLevel === 1) {
        bossSpawnThreshold = 0.5; // 50% for level 1
      } else if (currentLevel === 2) {
        bossSpawnThreshold = 0.8; // 80% for level 2 (was 65%)
      } else {
        bossSpawnThreshold = 0.85; // 85% for level 3 and above (was 75%)
      }
      
      // Debug log to track score and level progression
      if (DEBUG && frameCount % 60 === 0) { // Log once per second
        console.log(`Level: ${currentLevel}, Score: ${score}, Next Level: ${scoreForNextLevel}, Boss at: ${scoreForNextLevel * bossSpawnThreshold}`);
      }
      
      if (!miniBoss && !bossDefeated && score >= scoreForNextLevel * bossSpawnThreshold) {
        if (DEBUG) console.log(`Spawning boss for level ${currentLevel}. Score: ${score}, Required: ${scoreForNextLevel * bossSpawnThreshold}`);
        spawnMiniBoss(false); // Normal spawn, not forced
      }
      
      // Handle player input
      let moveSpeed = 5 * ship.speedBoost;
      
      if (keys[37] && ship.x > 15) { // Left arrow
        ship.x -= moveSpeed;
      }
      if (keys[39] && ship.x < canvas.width - 15) { // Right arrow
        ship.x += moveSpeed;
      }
      if (keys[38] && ship.y > 15) { // Up arrow
        ship.y -= moveSpeed;
      }
      if (keys[40] && ship.y < canvas.height - 15) { // Down arrow
        ship.y += moveSpeed;
      }
      
      // Regular shooting
      if (keys[32] && frameCount % 10 === 0 && !activePowerUps["Coffee Boost"]) { // Space bar
        bullets.push({
          x: ship.x,
          y: ship.y - 10,
          vx: 0,
          vy: -8
        });
      }
      
      // Update mini-boss if active
      if (miniBoss) {
        miniBoss.update();
      }
      
      // Update power-ups
      if (frameCount % 300 === 0 && Math.random() < 0.7) {
        createPowerUp();
      }
      
      for (let i = powerUps.length - 1; i >= 0; i--) {
        let powerUp = powerUps[i];
        powerUp.y += 1;
        
        if (powerUp.y > canvas.height + 50) {
          powerUps.splice(i, 1);
          continue;
        }
        
        // Check for collision with player
        let d = Math.sqrt(Math.pow(ship.x - powerUp.x, 2) + Math.pow(ship.y - powerUp.y, 2));
        if (d < powerUp.size / 2 + 15) {
          activatePowerUp(powerUp);
          powerUps.splice(i, 1);
        }
      }
      
      // Update active power-ups
      for (let name in activePowerUps) {
        let powerUp = activePowerUps[name];
        
        // Update timer
        powerUp.timer--;
        
        // Call update function
        if (powerUp.instance && powerUp.instance.onUpdate) {
          powerUp.instance.onUpdate();
        }
        
        // Deactivate if timer expired
        if (powerUp.timer <= 0) {
          if (powerUp.instance && powerUp.instance.onDeactivate) {
            powerUp.instance.onDeactivate();
          }
          delete activePowerUps[name];
        }
      }
      
      // Create obstacles
      // Frequency increases with level (60 frames at level 1, 50 at level 2, etc.)
      let obstacleFrequency = Math.max(20, 60 - (currentLevel - 1) * 10);
      if (frameCount % obstacleFrequency === 0) {
        createObstacle();
      }
      
      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        let obstacle = obstacles[i];
        
        obstacle.x += obstacle.vx;
        obstacle.y += obstacle.vy;
        
        // Check if obstacle is off-screen
        if (obstacle.x < -50 || obstacle.x > canvas.width + 50 || 
            obstacle.y < -50 || obstacle.y > canvas.height + 50) {
          obstacles.splice(i, 1);
          continue;
        }
        
        // Check for collision with player
        let d = Math.sqrt(Math.pow(ship.x - obstacle.x, 2) + Math.pow(ship.y - obstacle.y, 2));
        if (d < obstacle.size / 2 + 10) {
          gameOver();
          return;
        }
      }
      
      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        let bullet = bullets[i];
        
        // Update position
        if (bullet.vx !== undefined) {
          bullet.x += bullet.vx;
          bullet.y += bullet.vy;
        } else {
          bullet.y += bullet.vy;
        }
        
        // Remove bullets that are off-screen
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          bullets.splice(i, 1);
          continue;
        }
        
        // Skip collision checks for boss bullets
        if (bullet.fromBoss) {
          // Check for collision with player
          let d = Math.sqrt(Math.pow(ship.x - bullet.x, 2) + Math.pow(ship.y - bullet.y, 2));
          if (d < 15) {
            // Player hit by boss bullet
            if (!ship.shield) { // Shield protects from boss bullets
              gameOver();
              return;
            } else {
              // Shield absorbs the hit
              bullets.splice(i, 1);
              createTextParticle(ship.x, ship.y, "SHIELD BLOCKED!");
              continue;
            }
          }
          continue;
        }
        
        // Check for collisions with mini-boss
        if (miniBoss) {
          let d = Math.sqrt(Math.pow(bullet.x - miniBoss.x, 2) + Math.pow(bullet.y - miniBoss.y, 2));
          if (d < miniBoss.size / 2) {
            // Calculate damage
            let damage = ship.doubleDamage ? 2 : 1;
            miniBoss.takeDamage(damage);
            
            // Remove bullet
            bullets.splice(i, 1);
            continue;
          }
        }
        
        // Check for collisions with obstacles
        let hitObstacle = false;
        for (let j = obstacles.length - 1; j >= 0; j--) {
          let obstacle = obstacles[j];
          let d = Math.sqrt(Math.pow(bullet.x - obstacle.x, 2) + Math.pow(bullet.y - obstacle.y, 2));
          
          if (d < obstacle.size / 2) {
            // Calculate damage
            let damage = ship.doubleDamage ? 2 : 1;
            obstacle.health -= damage;
            
            // Remove bullet
            bullets.splice(i, 1);
            hitObstacle = true;
            
            // If obstacle is destroyed
            if (obstacle.health <= 0) {
              // Create explosion
              createExplosion(obstacle.x, obstacle.y, obstacle.size, obstacle.color);
              
              // Show text
              if (Math.random() < 0.2) { // 20% chance for pop culture reference
                let text = POP_CULTURE_TEXTS[Math.floor(Math.random() * POP_CULTURE_TEXTS.length)];
                createTextParticle(obstacle.x, obstacle.y, text);
              } else if (obstacle.texts && obstacle.texts.length > 0) {
                let text = obstacle.texts[Math.floor(Math.random() * obstacle.texts.length)];
                createTextParticle(obstacle.x, obstacle.y, text);
              } else {
                // Use level-specific explosion messages
                let currentLevelData = LEVELS[currentLevel - 1];
                if (currentLevelData && currentLevelData.explosionMessages) {
                  let text = currentLevelData.explosionMessages[Math.floor(Math.random() * currentLevelData.explosionMessages.length)];
                  createTextParticle(obstacle.x, obstacle.y, text);
                }
              }
              
              // Add score
              score += Math.floor(obstacle.size * 1.5);
              
              // Remove obstacle
              obstacles.splice(j, 1);
            }
            
            break;
          }
        }
        
        if (hitObstacle) continue;
      }
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        
        if (p.isShockwave) {
          p.radius += (p.maxRadius - p.radius) * 0.2;
        } else {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98;
          p.vy *= 0.98;
        }
        
        p.life--;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
      
      // Update text particles
      for (let i = textParticles.length - 1; i >= 0; i--) {
        let t = textParticles[i];
        t.y -= 1;
        t.life--;
        
        if (t.life <= 0) {
          textParticles.splice(i, 1);
        }
      }
    }
    
    // Draw game
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw stars
      ctx.fillStyle = '#fff';
      for (let star of stars) {
        ctx.fillRect(star.x, star.y, star.size, star.size);
      }
      
      // Draw obstacles
      for (let obstacle of obstacles) {
        ctx.fillStyle = `rgb(${obstacle.color[0]}, ${obstacle.color[1]}, ${obstacle.color[2]})`;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        
        // Draw different shapes based on obstacle type
        if (obstacle.name.includes("Homework") || obstacle.name.includes("Technical Debt")) {
          // Draw a paper/document shape
          ctx.save();
          ctx.translate(obstacle.x, obstacle.y);
          ctx.rotate(frameCount * 0.01);
          
          // Paper
          ctx.fillRect(-obstacle.size/2, -obstacle.size/2, obstacle.size, obstacle.size);
          
          // Lines of text
          ctx.strokeStyle = '#000';
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(-obstacle.size/2 + 5, -obstacle.size/3 + i * 10);
            ctx.lineTo(obstacle.size/2 - 5, -obstacle.size/3 + i * 10);
            ctx.stroke();
          }
          
          ctx.restore();
        } 
        else if (obstacle.name.includes("Mom") || obstacle.name.includes("Boss")) {
          // Draw an angry face
          ctx.save();
          ctx.translate(obstacle.x, obstacle.y);
          
          // Head
          ctx.beginPath();
          ctx.arc(0, 0, obstacle.size/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Angry eyes
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          
          // Left eye
          ctx.beginPath();
          ctx.moveTo(-obstacle.size/4 - 5, -obstacle.size/6 - 5);
          ctx.lineTo(-obstacle.size/4 + 5, -obstacle.size/6 + 5);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(-obstacle.size/4 - 5, -obstacle.size/6 + 5);
          ctx.lineTo(-obstacle.size/4 + 5, -obstacle.size/6 - 5);
          ctx.stroke();
          
          // Right eye
          ctx.beginPath();
          ctx.moveTo(obstacle.size/4 - 5, -obstacle.size/6 - 5);
          ctx.lineTo(obstacle.size/4 + 5, -obstacle.size/6 + 5);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(obstacle.size/4 - 5, -obstacle.size/6 + 5);
          ctx.lineTo(obstacle.size/4 + 5, -obstacle.size/6 - 5);
          ctx.stroke();
          
          // Angry mouth
          ctx.beginPath();
          ctx.arc(0, obstacle.size/4, obstacle.size/4, 0, Math.PI, false);
          ctx.stroke();
          
          ctx.restore();
        }
        else if (obstacle.name.includes("Lag") || obstacle.name.includes("Git")) {
          // Error symbol
          ctx.save();
          ctx.translate(obstacle.x, obstacle.y);
          ctx.rotate(frameCount * 0.02);
          
          // Warning triangle
          ctx.beginPath();
          ctx.moveTo(0, -obstacle.size/2);
          ctx.lineTo(-obstacle.size/2, obstacle.size/2);
          ctx.lineTo(obstacle.size/2, obstacle.size/2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Exclamation mark
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(0, obstacle.size/4, obstacle.size/10, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillRect(-obstacle.size/10, -obstacle.size/4, obstacle.size/5, obstacle.size/2);
          
          ctx.restore();
        }
        else if (obstacle.name.includes("Meeting") || obstacle.name.includes("Outage")) {
          // Clock shape
          ctx.save();
          ctx.translate(obstacle.x, obstacle.y);
          
          // Clock face
          ctx.beginPath();
          ctx.arc(0, 0, obstacle.size/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Clock hands
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          
          // Hour hand
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(
            Math.cos(frameCount * 0.01) * obstacle.size/4,
            Math.sin(frameCount * 0.01) * obstacle.size/4
          );
          ctx.stroke();
          
          // Minute hand
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(
            Math.cos(frameCount * 0.05) * obstacle.size/3,
            Math.sin(frameCount * 0.05) * obstacle.size/3
          );
          ctx.stroke();
          
          ctx.restore();
        }
        else {
          // Default - rotating asteroid-like shape
          ctx.save();
          ctx.translate(obstacle.x, obstacle.y);
          ctx.rotate(frameCount * 0.01);
          
          ctx.beginPath();
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = obstacle.size/2 * (0.8 + Math.sin(i * 3) * 0.2);
            
            if (i === 0) {
              ctx.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            } else {
              ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          ctx.restore();
        }
      }
      
      // Draw power-ups
      for (let powerUp of powerUps) {
        ctx.fillStyle = `rgb(${powerUp.color[0]}, ${powerUp.color[1]}, ${powerUp.color[2]})`;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        
        ctx.save();
        ctx.translate(powerUp.x, powerUp.y);
        
        // Rotate slowly
        ctx.rotate(frameCount * 0.02);
        
        // Draw different shapes based on power-up type
        if (powerUp.name.includes("Gaming") || powerUp.name.includes("Cheat")) {
          // Game controller shape
          ctx.fillRect(-powerUp.size/3, -powerUp.size/4, powerUp.size*2/3, powerUp.size/2);
          
          // Controller buttons
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(powerUp.size/6, 0, powerUp.size/10, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(0, 0, powerUp.size/10, 0, Math.PI * 2);
          ctx.fill();
        }
        else if (powerUp.name.includes("Stack") || powerUp.name.includes("Debug")) {
          // Stack Overflow logo-inspired shape
          ctx.beginPath();
          ctx.moveTo(-powerUp.size/3, -powerUp.size/3);
          ctx.lineTo(powerUp.size/3, -powerUp.size/3);
          ctx.lineTo(powerUp.size/3, powerUp.size/3);
          ctx.lineTo(-powerUp.size/3, powerUp.size/3);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Inner shape
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.moveTo(-powerUp.size/6, -powerUp.size/6);
          ctx.lineTo(powerUp.size/6, -powerUp.size/6);
          ctx.lineTo(powerUp.size/6, powerUp.size/6);
          ctx.lineTo(-powerUp.size/6, powerUp.size/6);
          ctx.closePath();
          ctx.fill();
        }
        else if (powerUp.name.includes("Coffee") || powerUp.name.includes("Weekend")) {
          // Coffee cup
          ctx.beginPath();
          ctx.moveTo(-powerUp.size/3, -powerUp.size/3);
          ctx.lineTo(powerUp.size/3, -powerUp.size/3);
          ctx.lineTo(powerUp.size/3, powerUp.size/3);
          ctx.lineTo(-powerUp.size/3, powerUp.size/3);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Cup handle
          ctx.beginPath();
          ctx.arc(powerUp.size/3, 0, powerUp.size/6, -Math.PI/2, Math.PI/2);
          ctx.stroke();
          
          // Steam
          ctx.beginPath();
          ctx.moveTo(-powerUp.size/6, -powerUp.size/3);
          ctx.quadraticCurveTo(
            -powerUp.size/6 + Math.sin(frameCount * 0.1) * 5, 
            -powerUp.size/3 - 10, 
            0, 
            -powerUp.size/3
          );
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(powerUp.size/6, -powerUp.size/3);
          ctx.quadraticCurveTo(
            powerUp.size/6 + Math.sin(frameCount * 0.1 + 1) * 5, 
            -powerUp.size/3 - 10, 
            0, 
            -powerUp.size/3
          );
          ctx.stroke();
        }
        else if (powerUp.name.includes("Duck")) {
          // Rubber duck
          ctx.fillStyle = '#ffff00';
          
          // Duck body
          ctx.beginPath();
          ctx.arc(0, 0, powerUp.size/3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Duck bill
          ctx.fillStyle = '#ff9900';
          ctx.beginPath();
          ctx.ellipse(powerUp.size/3, 0, powerUp.size/6, powerUp.size/10, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Duck eye
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(powerUp.size/12, -powerUp.size/12, powerUp.size/15, 0, Math.PI * 2);
          ctx.fill();
        }
        else {
          // Default star shape for other power-ups
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
            const outerRadius = powerUp.size / 2;
            const innerRadius = powerUp.size / 4;
            
            const outerX = Math.cos(angle) * outerRadius;
            const outerY = Math.sin(angle) * outerRadius;
            
            const innerAngle = angle + Math.PI / 5;
            const innerX = Math.cos(innerAngle) * innerRadius;
            const innerY = Math.sin(innerAngle) * innerRadius;
            
            if (i === 0) {
              ctx.moveTo(outerX, outerY);
            } else {
              ctx.lineTo(outerX, outerY);
            }
            
            ctx.lineTo(innerX, innerY);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Pulsating effect
          ctx.globalAlpha = 0.5 + Math.sin(frameCount * 0.1) * 0.3;
          ctx.beginPath();
          ctx.arc(0, 0, powerUp.size / 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        ctx.restore();
      }
      
      // Draw bullets
      for (let bullet of bullets) {
        if (bullet.special) {
          // Special bullets (from power-ups)
          if (bullet.ai) {
            // AI Assistant bullets
            ctx.fillStyle = '#00c8ff';
            ctx.strokeStyle = '#0088ff';
            ctx.lineWidth = 1;
            
            // Draw an AI bullet (brain-like shape)
            ctx.save();
            ctx.translate(bullet.x, bullet.y);
            
            // Rotate based on velocity
            if (bullet.vx !== undefined) {
              ctx.rotate(Math.atan2(bullet.vy, bullet.vx));
            }
            
            // AI shape
            ctx.beginPath();
            ctx.arc(-2, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Add some "neural connections"
            ctx.strokeStyle = '#80e8ff';
            ctx.beginPath();
            ctx.moveTo(3, 0);
            ctx.lineTo(8, -3);
            ctx.moveTo(3, 0);
            ctx.lineTo(8, 3);
            ctx.stroke();
            
            ctx.restore();
          } else {
            // Regular special bullets (from power-ups)
            ctx.fillStyle = '#ff0';
            ctx.strokeStyle = '#f80';
            ctx.lineWidth = 1;
            
            // Draw a special bullet (code snippet)
            ctx.save();
            ctx.translate(bullet.x, bullet.y);
            
            // Rotate based on velocity
            if (bullet.vx !== undefined) {
              ctx.rotate(Math.atan2(bullet.vy, bullet.vx));
            }
            
            // Code snippet shape
            ctx.fillRect(-6, -3, 12, 6);
            ctx.strokeRect(-6, -3, 12, 6);
            
            // Code lines
            ctx.strokeStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(-4, -1);
            ctx.lineTo(4, -1);
            ctx.moveTo(-4, 1);
            ctx.lineTo(2, 1);
            ctx.stroke();
            
            // Glowing effect
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.fill();
            ctx.globalAlpha = 1;
            
            ctx.restore();
          }
        } else if (bullet.fromBoss) {
          // Boss bullets
          ctx.fillStyle = bullet.color ? `rgb(${bullet.color[0]}, ${bullet.color[1]}, ${bullet.color[2]})` : '#f00';
          
          // Draw a boss bullet (warning symbol)
          ctx.save();
          ctx.translate(bullet.x, bullet.y);
          
          // Rotate based on velocity
          ctx.rotate(Math.atan2(bullet.vy, bullet.vx));
          
          // Warning triangle
          ctx.beginPath();
          ctx.moveTo(0, -6);
          ctx.lineTo(-6, 6);
          ctx.lineTo(6, 6);
          ctx.closePath();
          ctx.fill();
          
          // Exclamation mark
          ctx.fillStyle = '#000';
          ctx.fillRect(-1, -3, 2, 6);
          ctx.beginPath();
          ctx.arc(0, 4, 1, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        } else {
          // Regular bullets
          ctx.fillStyle = '#0f0';
          
          // Draw a nerdy bullet (binary code)
          ctx.save();
          ctx.translate(bullet.x, bullet.y);
          
          // Rotate based on velocity
          if (bullet.vx !== undefined) {
            ctx.rotate(Math.atan2(bullet.vy, bullet.vx));
          }
          
          // Binary code shape
          ctx.fillRect(-4, -2, 8, 4);
          
          // Binary digits
          ctx.fillStyle = '#000';
          ctx.font = '4px monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Random binary digits that change
          const binary = (frameCount % 2 === 0) ? "10" : "01";
          ctx.fillText(binary, 0, 0);
          
          ctx.restore();
        }
      }
      
      // Draw mini-boss if active
      if (miniBoss) {
        miniBoss.draw();
      }
      
      // Draw particles
      for (let p of particles) {
        if (p.isShockwave) {
          let alpha = p.life / p.maxLife;
          ctx.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha})`;
          ctx.lineWidth = 2;
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          let alpha = p.life / p.maxLife;
          ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha})`;
          
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
      }
      
      // Draw text particles
      for (let t of textParticles) {
        let alpha = t.life / 180;
        
        // Shadow
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.font = `${16 * t.scale}px "Courier New", monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(t.text, t.x + 2, t.y + 2);
        
        // Text with bright color
        ctx.fillStyle = `rgba(255, 255, 100, ${alpha})`;
        ctx.fillText(t.text, t.x, t.y);
      }
      
      // Draw player ship
      ctx.save();
      ctx.translate(ship.x, ship.y);
      
      // Draw power-up effects
      if (activePowerUps["Debug Mode"]) {
        ctx.save();
        ctx.rotate(frameCount * 0.05);
        for (let i = 0; i < 4; i++) {
          ctx.rotate(Math.PI/2);
          ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
          ctx.beginPath();
          ctx.moveTo(0, -25);
          ctx.lineTo(-5, -18);
          ctx.lineTo(5, -18);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }
      
      if (activePowerUps["Coffee Boost"]) {
        for (let i = 1; i <= 3; i++) {
          ctx.fillStyle = `rgba(0, 255, 0, ${0.3 - i * 0.08})`;
          ctx.beginPath();
          ctx.moveTo(0, -15 + i * 5);
          ctx.lineTo(-10 + i, 10 + i * 3);
          ctx.lineTo(10 - i, 10 + i * 3);
          ctx.closePath();
          ctx.fill();
        }
      }
      
      if (activePowerUps["Stack Overflow"]) {
        ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw ship
      ctx.fillStyle = '#0f0';
      ctx.strokeStyle = '#0c0';
      ctx.lineWidth = 2;
      
      // Ship body - more detailed spaceship
      ctx.beginPath();
      ctx.moveTo(0, -15);
      ctx.lineTo(-12, 5);
      ctx.lineTo(-8, 10);
      ctx.lineTo(8, 10);
      ctx.lineTo(12, 5);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Ship cockpit
      ctx.fillStyle = '#cfc';
      ctx.beginPath();
      ctx.ellipse(0, -5, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Nerdy glasses
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(-3, -5, 3, 3, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.ellipse(3, -5, 3, 3, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Bridge between glasses
      ctx.beginPath();
      ctx.moveTo(0, -5);
      ctx.lineTo(-3, -5);
      ctx.moveTo(0, -5);
      ctx.lineTo(3, -5);
      ctx.stroke();
      
      // Ship engines
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.rect(-8, 10, 4, 3);
      ctx.rect(4, 10, 4, 3);
      ctx.fill();
      
      // Engine flames when moving
      if (keys[37] || keys[38] || keys[39] || keys[40]) {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(-8, 13);
        ctx.lineTo(-6, 13);
        ctx.lineTo(-7, 13 + Math.random() * 5 + 3);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(8, 13);
        ctx.lineTo(6, 13);
        ctx.lineTo(7, 13 + Math.random() * 5 + 3);
        ctx.fill();
      }
      
      ctx.restore();
      
      // Draw active power-up indicators
      let powerUpX = 130;
      for (let name in activePowerUps) {
        let powerUp = activePowerUps[name];
        
        // Draw indicator
        ctx.fillStyle = `rgb(${powerUp.type.color[0]}, ${powerUp.type.color[1]}, ${powerUp.type.color[2]})`;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.fillRect(powerUpX, 10, 40, 15);
        ctx.strokeRect(powerUpX, 10, 40, 15);
        
        // Draw timer bar
        let timerWidth = (powerUp.timer / powerUp.type.duration) * 40;
        ctx.fillStyle = '#fff';
        ctx.fillRect(powerUpX, 25, timerWidth, 3);
        
        // Draw text
        ctx.fillStyle = '#fff';
        ctx.font = '9px "Courier New"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(name.substring(0, 8), powerUpX + 20, 18);
        
        powerUpX += 50;
      }
      
      // Draw score
      ctx.fillStyle = '#0f0';
      ctx.font = '20px "Courier New"';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`SCORE: ${score}`, 10, 10);
      
      // Draw level progress
      if (currentLevel < LEVELS.length) {
        ctx.fillStyle = '#0f0';
        ctx.font = '12px "Courier New"';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(`NEXT LEVEL: ${score}/${scoreForNextLevel}`, 10, 35);
        
        // Draw progress bar
        let progressWidth = Math.min(1, score / scoreForNextLevel) * 100;
        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.fillRect(10, 50, 100, 5);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(10, 50, progressWidth, 5);
      }
      
      // Draw controls info
      ctx.fillStyle = '#0f0';
      ctx.font = '12px "Courier New"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('ARROWS: move | SPACE: shoot', canvas.width/2, canvas.height - 5);
    }
    
    // Create a random power-up
    function createPowerUp() {
      // Get level-specific power-ups if available
      let currentLevelData = LEVELS[currentLevel - 1];
      let powerUpName;
      
      if (currentLevelData && currentLevelData.powerUps && currentLevelData.powerUps.length > 0 && Math.random() < 0.7) {
        // 70% chance to use a level-specific power-up
        powerUpName = currentLevelData.powerUps[Math.floor(Math.random() * currentLevelData.powerUps.length)];
      }
      
      // Find matching power-up or use a random one
      let powerUpType;
      if (powerUpName) {
        powerUpType = POWER_UP_TYPES.find(p => p.name === powerUpName);
      }
      
      // Fallback to random if not found
      if (!powerUpType) {
        powerUpType = POWER_UP_TYPES[Math.floor(Math.random() * POWER_UP_TYPES.length)];
      }
      
      powerUps.push({
        type: powerUpType,
        name: powerUpType.name,
        x: Math.random() * (canvas.width - 100) + 50,
        y: -30,
        size: powerUpType.size,
        color: powerUpType.color
      });
    }
    
    // Activate a power-up
    function activatePowerUp(powerUp) {
      // Create power-up instance
      let instance = powerUp.type.effect(ship);
      
      // Call activate function
      if (instance.onActivate) {
        instance.onActivate();
      }
      
      // Add to active power-ups
      activePowerUps[powerUp.name] = {
        type: powerUp.type,
        timer: powerUp.type.duration,
        instance: instance
      };
      
      // Show power-up message as a single text particle with the name
      createTextParticle(ship.x, ship.y - 50, powerUp.name + " ACTIVATED!");
    }
    
    // Create an obstacle
    function createObstacle() {
      // Get level-specific obstacles if available
      let currentLevelData = LEVELS[currentLevel - 1];
      let obstacleName;
      
      if (currentLevelData && currentLevelData.obstacles && currentLevelData.obstacles.length > 0) {
        obstacleName = currentLevelData.obstacles[Math.floor(Math.random() * currentLevelData.obstacles.length)];
      }
      
      // Find matching obstacle or use a random one
      let obstacleType;
      if (obstacleName) {
        obstacleType = OBSTACLE_TYPES.find(o => o.name === obstacleName);
      }
      
      // Fallback to random if not found
      if (!obstacleType) {
        obstacleType = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
      }
      
      // Choose random edge to spawn from
      let edge = Math.floor(Math.random() * 4);
      let x, y;
      
      // Position obstacle at a random edge
      switch (edge) {
        case 0: // Top
          x = Math.random() * canvas.width;
          y = -obstacleType.size;
          break;
        case 1: // Right
          x = canvas.width + obstacleType.size;
          y = Math.random() * canvas.height;
          break;
        case 2: // Bottom
          x = Math.random() * canvas.width;
          y = canvas.height + obstacleType.size;
          break;
        case 3: // Left
          x = -obstacleType.size;
          y = Math.random() * canvas.height;
          break;
      }
      
      // Calculate velocity towards player with some randomness
      let angle = Math.atan2(ship.y - y, ship.x - x);
      angle += (Math.random() - 0.5) * 0.5; // Add some randomness
      
      // Base speed increases with level
      let levelSpeedMultiplier = 1 + (currentLevel - 1) * 0.2; // 20% speed increase per level
      let speed = (Math.random() * 1.5 + 1) * levelSpeedMultiplier;
      let vx = Math.cos(angle) * speed;
      let vy = Math.sin(angle) * speed;
      
      // Apply weekend mode slowdown if active
      if (activePowerUps["Weekend Mode"]) {
        vx *= 0.3;
        vy *= 0.3;
      }
      
      // Create obstacle object
      obstacles.push({
        name: obstacleType.name,
        size: obstacleType.size,
        color: obstacleType.color,
        health: obstacleType.health + Math.floor((currentLevel - 1) / 2), // Health increases every 2 levels
        texts: obstacleType.texts,
        x: x,
        y: y,
        vx: vx,
        vy: vy
      });
    }
    
    // Create explosion effect
    function createExplosion(x, y, size, color) {
      // Limiter le nombre maximum de particules
      const MAX_PARTICLES_PER_EXPLOSION = 15;
      const MAX_TOTAL_PARTICLES = 50;
      
      // Limiter le nombre de particules en fonction de la taille, mais avec un maximum
      let particleCount = Math.min(Math.floor(size / 3), MAX_PARTICLES_PER_EXPLOSION);
      
      // Si on d√©passe le nombre maximum de particules, supprimer les plus anciennes
      if (particles.length > MAX_TOTAL_PARTICLES - particleCount) {
        particles.splice(0, particleCount);
      }
      
      // Pr√©calculer certaines valeurs pour √©viter les calculs r√©p√©titifs
      const twoPI = Math.PI * 2;
      
      for (let i = 0; i < particleCount; i++) {
        let angle = Math.random() * twoPI;
        let speed = Math.random() * 2 + 1; // R√©duire l√©g√®rement la vitesse
        
        // Pr√©calculer les composantes de vitesse
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        
        particles.push({
          x: x,
          y: y,
          vx: vx,
          vy: vy,
          size: Math.random() * 2 + 1, // R√©duire l√©g√®rement la taille
          color: color,
          life: Math.random() * 15 + 15, // R√©duire l√©g√®rement la dur√©e de vie
          maxLife: 30
        });
      }
      
      // Ajouter une onde de choc uniquement si on n'en a pas trop
      if (particles.filter(p => p.isShockwave).length < 5) {
        particles.push({
          x: x,
          y: y,
          radius: 5,
          maxRadius: size,
          color: [255, 255, 255],
          life: 10, // R√©duire la dur√©e de vie
          maxLife: 10,
          isShockwave: true
        });
      }
    }
    
    // Spawn a mini-boss for the current level
    function spawnMiniBoss(forceSpawn = false) {
      // Only check for bossDefeated if not forcing spawn
      if (miniBoss || (!forceSpawn && bossDefeated)) return; // Don't spawn if one already exists or was defeated (unless forced)
      
      const bossData = MINI_BOSSES[currentLevel - 1];
      if (!bossData) return; // Safety check
      
      // Announce the boss
      createTextParticle(canvas.width / 2, canvas.height / 2 - 50, "BOSS APPROACHING:");
      createTextParticle(canvas.width / 2, canvas.height / 2, bossData.name);
      createTextParticle(canvas.width / 2, canvas.height / 2 + 50, bossData.description);
      
      // Adjust shoot interval based on level to make higher level bosses more manageable
      let adjustedShootInterval = bossData.shootInterval;
      if (currentLevel > 1) {
        // Add 10 frames to the interval for each level above 1
        adjustedShootInterval += (currentLevel - 1) * 10;
      }
      
      // Create the mini-boss
      miniBoss = {
        name: bossData.name,
        description: bossData.description,
        health: bossData.health,
        maxHealth: bossData.health,
        size: bossData.size,
        color: bossData.color,
        x: canvas.width / 2,
        y: -bossData.size, // Start off-screen
        targetY: 80, // Target position (moved higher up)
        speed: bossData.speed,
        shootTimer: adjustedShootInterval,
        shootInterval: adjustedShootInterval,
        attackMessages: bossData.attackMessages,
        phase: 1, // Boss phases for different attack patterns
        phaseTimer: 300, // Time before changing phases
        entryDelay: 180, // Delay before boss starts attacking (3 seconds at 60fps)
        isAttacking: false, // Flag to control when boss starts attacking
        
        update: function() {
          // Move towards target position
          if (this.y < this.targetY) {
            this.y += this.speed;
          }
          
          // Entry delay before attacking
          if (!this.isAttacking) {
            if (this.entryDelay > 0) {
              this.entryDelay--;
              // Show warning message when almost ready to attack
              if (this.entryDelay === 60) {
                createTextParticle(this.x, this.y - 40, "Preparing to attack!");
              }
            } else {
              this.isAttacking = true;
              createTextParticle(this.x, this.y - 40, "Attack mode activated!");
            }
            return; // Skip the rest of the update until ready to attack
          }
          
          // Horizontal movement based on phase
          if (this.phase === 1) {
            // Phase 1: Side-to-side movement
            this.x = canvas.width / 2 + Math.sin(frameCount * 0.02) * (canvas.width / 3);
          } else if (this.phase === 2) {
            // Phase 2: Chase player but with limited speed based on level
            const dx = ship.x - this.x;
            // Reduce chase speed for higher levels to make it more manageable
            const chaseSpeedFactor = Math.max(0.2, 0.5 - (currentLevel - 1) * 0.1);
            this.x += (dx > 0 ? 1 : -1) * this.speed * chaseSpeedFactor;
          }
          
          // Shooting logic
          this.shootTimer--;
          if (this.shootTimer <= 0) {
            this.shoot();
            this.shootTimer = this.shootInterval;
          }
          
          // Phase change logic
          this.phaseTimer--;
          if (this.phaseTimer <= 0) {
            this.phase = this.phase === 1 ? 2 : 1;
            this.phaseTimer = 300;
            createTextParticle(this.x, this.y - 40, "Phase " + this.phase + " activated!");
          }
          
          // Constrain to canvas
          this.x = Math.max(this.size / 2, Math.min(canvas.width - this.size / 2, this.x));
        },
        
        shoot: function() {
          // Display attack message
          if (this.attackMessages && this.attackMessages.length > 0) {
            const message = this.attackMessages[Math.floor(Math.random() * this.attackMessages.length)];
            createTextParticle(this.x, this.y - 40, message);
          }
          
          if (this.phase === 1) {
            // Phase 1: Spread shot
            for (let i = -2; i <= 2; i++) {
              const angle = Math.PI / 2 + (i * Math.PI / 10);
              bullets.push({
                x: this.x,
                y: this.y + this.size / 2,
                vx: Math.cos(angle) * 4,
                vy: Math.sin(angle) * 4,
                fromBoss: true,
                color: this.color
              });
            }
          } else {
            // Phase 2: Targeted shot
            const dx = ship.x - this.x;
            const dy = ship.y - this.y;
            const angle = Math.atan2(dy, dx);
            
            bullets.push({
              x: this.x,
              y: this.y + this.size / 2,
              vx: Math.cos(angle) * 5,
              vy: Math.sin(angle) * 5,
              fromBoss: true,
              color: this.color
            });
            
            // Add two more bullets with slight angle variation
            bullets.push({
              x: this.x,
              y: this.y + this.size / 2,
              vx: Math.cos(angle + 0.2) * 5,
              vy: Math.sin(angle + 0.2) * 5,
              fromBoss: true,
              color: this.color
            });
            
            bullets.push({
              x: this.x,
              y: this.y + this.size / 2,
              vx: Math.cos(angle - 0.2) * 5,
              vy: Math.sin(angle - 0.2) * 5,
              fromBoss: true,
              color: this.color
            });
          }
        },
        
        draw: function() {
          // Draw boss body
          ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Draw boss features based on level
          if (currentLevel === 1) {
            // Gaming Addiction: Game controller features
            ctx.fillStyle = '#fff';
            // Eyes (like controller buttons)
            ctx.beginPath();
            ctx.arc(this.x - 15, this.y - 10, 8, 0, Math.PI * 2);
            ctx.arc(this.x + 15, this.y - 10, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry mouth
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y + 15, 20, 0.1 * Math.PI, 0.9 * Math.PI, false);
            ctx.stroke();
          } else if (currentLevel === 2) {
            // Imposter Syndrome: Question marks
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', this.x - 15, this.y - 10);
            ctx.fillText('?', this.x + 15, this.y - 10);
            
            // Worried mouth
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y + 15, 15, 0.8 * Math.PI, 0.2 * Math.PI, true);
            ctx.stroke();
          } else if (currentLevel === 3) {
            // Burnout: Flames
            ctx.fillStyle = '#ff0';
            
            // Flame eyes
            for (let i = 0; i < 5; i++) {
              ctx.beginPath();
              ctx.ellipse(
                this.x - 15, 
                this.y - 10 - i * 3, 
                5, 
                8 - i, 
                0, 0, Math.PI * 2
              );
              ctx.fill();
              
              ctx.beginPath();
              ctx.ellipse(
                this.x + 15, 
                this.y - 10 - i * 3, 
                5, 
                8 - i, 
                0, 0, Math.PI * 2
              );
              ctx.fill();
            }
            
            // Exhausted mouth
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x - 20, this.y + 15);
            ctx.lineTo(this.x + 20, this.y + 15);
            ctx.stroke();
          } else if (currentLevel === 4) {
            // Mortgage & Bills: Dollar signs
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$', this.x - 15, this.y - 10);
            ctx.fillText('$', this.x + 15, this.y - 10);
            
            // Greedy smile
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y + 10, 20, 1.1 * Math.PI, 1.9 * Math.PI, false);
            ctx.stroke();
          } else {
            // Midlife Crisis: Clock features
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            
            // Clock face
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Clock hands
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
              this.x + Math.cos(frameCount * 0.1) * this.size / 4,
              this.y + Math.sin(frameCount * 0.1) * this.size / 4
            );
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
              this.x + Math.cos(frameCount * 0.01) * this.size / 6,
              this.y + Math.sin(frameCount * 0.01) * this.size / 6
            );
            ctx.stroke();
          }
          
          // Draw health bar
          const healthPercent = this.health / this.maxHealth;
          const barWidth = this.size * 1.5;
          
          // Background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 15, barWidth, 10);
          
          // Health
          ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
          ctx.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 15, barWidth * healthPercent, 10);
          
          // Border
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1;
          ctx.strokeRect(this.x - barWidth / 2, this.y - this.size / 2 - 15, barWidth, 10);
          
          // Boss name
          ctx.fillStyle = '#fff';
          ctx.font = '12px "Courier New"';
          ctx.textAlign = 'center';
          ctx.fillText(this.name, this.x, this.y - this.size / 2 - 25);
        },
        
        takeDamage: function(amount) {
          this.health -= amount;
          
          // Visual feedback
          createTextParticle(this.x, this.y, "-" + amount);
          
          // Check if defeated
          if (this.health <= 0) {
            this.defeat();
          } else if (this.health <= this.maxHealth * 0.5 && this.phase === 1) {
            // Force phase change at 50% health if still in phase 1
            this.phase = 2;
            this.phaseTimer = 300;
            createTextParticle(this.x, this.y - 40, "You've made me angry!");
          }
        },
        
        defeat: function() {
          // Create big explosion
          for (let i = 0; i < 30; i++) {
            createExplosion(
              this.x + (Math.random() - 0.5) * this.size,
              this.y + (Math.random() - 0.5) * this.size,
              this.size / 3,
              this.color
            );
          }
          
          // Add score
          score += this.maxHealth * 10;
          
          // Show victory message
          createTextParticle(canvas.width / 2, canvas.height / 2 - 30, this.name + " DEFEATED!");
          createTextParticle(canvas.width / 2, canvas.height / 2, "BONUS: " + (this.maxHealth * 10) + " POINTS!");
          
          // Mark as defeated
          miniBoss = null;
          bossDefeated = true;
          
          // Check if this is the final boss (level 5)
          if (currentLevel === 5) {
            setTimeout(function() {
              showEndScreen();
            }, 2000); // Show end screen after 2 seconds
          }
        }
      };
    }
    
    // Create floating text
    function createTextParticle(x, y, text) {
      // Limiter le nombre maximum de particules de texte
      const MAX_TEXT_PARTICLES = 10;
      
      // Si on d√©passe le maximum, supprimer les plus anciennes
      if (textParticles.length >= MAX_TEXT_PARTICLES) {
        textParticles.shift(); // Supprimer la plus ancienne
      }
      
      textParticles.push({
        x: x,
        y: y,
        text: text,
        life: 120, // R√©duire l√©g√®rement la dur√©e de vie
        scale: 1.5  // Add scale for larger text
      });
    }
    
    // Check if game is completed (level 5 boss defeated or score >= 7500)
    function checkGameCompletion() {
      // Only check for completion in level 5
      if (currentLevel === 5) {
        if ((miniBoss && miniBoss.health <= 0) || score >= 7500) {
          showEndScreen();
        }
      }
    }
    
    // Show end screen
    function showEndScreen() {
      gameRunning = false;
      document.getElementById('endScreen').style.display = 'flex';
    }
    
    // Continue playing after end screen
    function continuePlaying() {
      document.getElementById('endScreen').style.display = 'none';
      gameRunning = true;
      requestAnimationFrame(gameLoop);
    }
    
    
    
    // Function to close leaderboard
    
    
    // Start the game
    init();
  </script>
</body>
</html>